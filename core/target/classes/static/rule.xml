<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<rule>

    <rule-item>
        <rule-name>UnusedImportsRefactor</rule-name>
        <description>清除未使用的导入</description>
        <className>analysis.rule.UnusedImportsRule</className>
        <solutionClassName>refactor.refactorimpl.UnusedImportsRefactor</solutionClassName>
        <rule-status>false</rule-status>
        <rule-message>该导入未被使用 需要清除</rule-message>
        <rule-level>1</rule-level>
        <example>
            import com.github.javaparser.ast.ImportDeclaration;
            import model.Issue;
            import refactor.AbstractRefactor;

            class xx{
                /*
                * not use that imports
                */
            }
        </example>
    </rule-item>

    <rule-item>
        <rule-name>CodeStyleRule</rule-name>
        <description>大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上</description>
        <className>analysis.rule.CodeStyleRule</className>
        <solutionClassName>refactor.refactorimpl.CodeStyleRefactor</solutionClassName>
        <rule-status>false</rule-status>
        <rule-message>必须用大括号包裹 即使只有一条语句或空</rule-message>
        <rule-level>0</rule-level>
        <example>
            do:
                xxx
            while(condition);

            if(condtion)
                xxx
            else
                xxx

            while(condition)
                xxxx

            for(init;condition;update)
                xxxx
        </example>
    </rule-item>

    <rule-item>
        <rule-name>DeeplyIfStmtsRule</rule-name>
        <description>if深层嵌套</description>
        <className>analysis.rule.DeeplyIfStmtsRule</className>
        <solutionClassName>refactor.refactorimpl.DeeplyIfStmtsRefactor</solutionClassName>
        <rule-status>false</rule-status>
        <rule-message>if深层嵌套超过三层</rule-message>
        <rule-level>10</rule-level>
        <example>
            if (i == 1) {
                System.out.println("执行1");
                if (i == 2) {
                    System.out.println("执行2");
                        if (i == 3) {
                            System.out.println("执行3");
                                if (i == 4) {
                                    System.out.println("执行4");
                                        if (i == 5) {
                                            System.out.println("执行5");
                                                if (i == 6) {
                                                    System.out.println("执行6");
                                                        if (i == 7) {
                                                             System.out.println("执行7");
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
        </example>
    </rule-item>

    <rule-item>
        <rule-name>ShallowSwitchRule</rule-name>
        <description>Switch转换为if</description>
        <className>analysis.rule.ShallowSwitchRule</className>
        <solutionClassName>refactor.refactorimpl.ShallowSwitchRefactor</solutionClassName>
        <rule-status>false</rule-status>
        <rule-message>Switch低于或等于三层是低效的,故将其转换为if语句</rule-message>
        <rule-level>9</rule-level>
        <example>
            switch (empType)
            {
                case ENGINEER:
                     return m_basicSalary;
                case SALESMAN:
                    return m_basicSalary + m_commission;
                case MANAGER:
                    return 2 * m_basicSalary;
                default:
                    throw new Exception("no such employee type!");
            }
        </example>
    </rule-item>

    <rule-item>
        <rule-name>VoidPoolRule</rule-name>
        <description>空表达式for转换为while</description>
        <className>analysis.rule.VoidPoolRule</className>
        <solutionClassName>refactor.refactorimpl.VoidPoolRefactor</solutionClassName>
        <rule-status>false</rule-status>
        <rule-message>相较于for(;;), while(true)更加的容易使人理解</rule-message>
        <rule-level>8</rule-level>
        <example>
           for(;;){
                ****
            }
        </example>
    </rule-item>


    <rule-item>
        <rule-name>WhileChangeForRule</rule-name>
        <description>while转化为for</description>
        <className>analysis.rule.WhileChangeForRule</className>
        <solutionClassName>refactor.refactorimpl.WhileChangeRefactor</solutionClassName>
        <rule-status>false</rule-status>
        <rule-message>有些时候while转化成for能够使人更好的理解</rule-message>
        <rule-level>8</rule-level>
        <example>
            int i = 0;
            while(i &lt; 100){
                ****
                ****
                i++;
            }
        </example>
    </rule-item>


    <rule-item>
        <rule-name>IFTransformSwitchRule</rule-name>
        <description>if转换成switch</description>
        <className>analysis.rule.IFTransformSwitchRule</className>
        <solutionClassName>refactor.refactorimpl.IfTransformSwitchRefactor</solutionClassName>
        <rule-status>false</rule-status>
        <rule-message>if转换成switch性能更高哦</rule-message>
        <rule-level>8</rule-level>
        <example>
            if(x == q){
            xxxx
            }else if(x==p){
            xxxx
            }else if(x==t){
            xxxx
            }else if(x==c){
            xxxx
            }else if(x==z){
            xxxx
            }else if(x==n){
            xxxx
            }else{
            }
        </example>
    </rule-item>
    <rule-item>
        <rule-name>ClassNamingShouldBeCamelRule</rule-name>
        <description>类名使用UpperCamelCase风格，必须遵从驼峰形式，</description>
        <className>analysis.rule.ClassNamingShouldBeCamelRule</className>
        <solutionClassName>refactor.refactorimpl.ClassNameRefactor</solutionClassName>
        <rule-status>true</rule-status>
        <rule-message>类名应遵从驼峰形式</rule-message>
        <rule-level>2</rule-level>
        <example>
            public class TextName
        </example>
    </rule-item>
    <rule-item>
        <rule-name>ClassVariNamingRule</rule-name>
        <description>成员变量名字应遵从小驼峰模式</description>
        <className>analysis.rule.ClassVariNamingRule</className>
        <solutionClassName>refactor.refactorimpl.ClassVariNameRefactor</solutionClassName>
        <rule-status>false</rule-status>
        <rule-message>成员变量名应遵从小驼峰形式</rule-message>
        <rule-level>2</rule-level>
        <example>
            public class TextName{
                public string textName
            }
        </example>
    </rule-item>
    <rule-item>
        <rule-name>ClassConstantNamingRule</rule-name>
        <description>常量命名应该全部大写</description>
        <className>analysis.rule.ClassConstantNamingRule</className>
        <solutionClassName>refactor.refactorimpl.ContantNameRefactor</solutionClassName>
        <rule-status>false</rule-status>
        <rule-message>常量命名应该全部大写</rule-message>
        <rule-level>2</rule-level>
        <example>
            public class TextName
            {
            public static final PATTERN="";
            }
        </example>
    </rule-item>
    <rule-item>
        <rule-name>LowerCamelCaseVariableNaming</rule-name>
        <description>方法内变量名应符合小驼峰形式</description>
        <className>analysis.rule.LowerCamelCaseVariableNaming</className>
        <solutionClassName>refactor.refactorimpl.VariableNameRefactor</solutionClassName>
        <rule-status>false</rule-status>
        <rule-message>方法内变量应符合小驼峰形式</rule-message>
        <rule-level>2</rule-level>
        <example>
            public class TextName
            {
                public void check(){
                    String changeKey="";
            }
            }
        </example>
    </rule-item>
    <rule-item>
        <rule-name>MethodNamingShouldBeCamelRule</rule-name>
        <description>方法名应符合小驼峰形式</description>
        <className>analysis.rule.MethodNamingShouldBeCamelRule</className>
        <solutionClassName>refactor.refactorimpl.MethodNameRefactor</solutionClassName>
        <rule-status>false</rule-status>
        <rule-message>方法命名应该全部大写</rule-message>
        <rule-level>2</rule-level>
        <example>
            public class TextName
            {
                public void checkName(){
            }
            }
        </example>
    </rule-item>
    <rule-item>
        <rule-name>PackageNamingRule</rule-name>
        <description>包命名应该全部小写</description>
        <className>analysis.rule.PackageNamingRule</className>
        <solutionClassName>refactor.refactorimpl.PackageNameRefactor</solutionClassName>
        <rule-status>false</rule-status>
        <rule-message>包命名应该全部小写</rule-message>
        <rule-level>2</rule-level>
        <example>
            package com.github.javaparser;
            public class TextName
            {

            }
        </example>
    </rule-item>
    <rule-item>
        <rule-name>ParameterNamingRule</rule-name>
        <description>方法的参数命名应符合小驼峰形式</description>
        <className>analysis.rule.ParameterNamingRule</className>
        <solutionClassName>refactor.refactorimpl.ParameterNameRefactor</solutionClassName>
        <rule-status>false</rule-status>
        <rule-message>方法的参数命名应符合小驼峰形式</rule-message>
        <rule-level>2</rule-level>
        <example>
            public class TextName
            {
                public void checkName(String className)
                {

                }
            }
        </example>
    </rule-item>
</rule>